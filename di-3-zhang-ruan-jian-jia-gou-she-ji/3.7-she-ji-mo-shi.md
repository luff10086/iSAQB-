# 3.7设计模式

\
除了架构模式，设计模式在软件架构中也起着重要作用。这两种类型的模式通常都提供结构和技术解决方案。\
架构模式通常有助于组件的分解和组合，而设计模式更常用于支持功能的实现。\
然而，这两个类别之间的界限是模糊的。\
最著名的设计模式是由“四人帮”（Gamma、Helm、Johnson 和 Vlissides）描述的，也简称为 GoF。适配器是一种 GoF 模式，当两个类由于接口不兼容而无法相互通信时，它有助于进行转换。\
代理是一种结构模式。它通过提供相同的接口和对对象的引用来控制对实际对象的访问。\
外观充当子系统的简化接口。子系统通常包含许多外部未使用且隐藏的类和方法。在这种情况下，使用外观会有所帮助。

#### &#xD;3.7.1 适配器

如果您希望使用一个已有的模块，但其接口与您所需的接口不兼容，适配器模式可以提供帮助。\
适配器用于适配接口。

图3-22Adapter

#### &#xD;3.7.2 观察者

如果一个组件应该能够在无需知道其他组件是什么或者有多少组件需要更改的情况下通知其他组件，那么您应该使用此模式。\
观察者应该对主题的状态变化做出反应，而主题并不知道观察者。

图3-23Observer\
主题对其观察者唯一知道的是它们实现了观察者接口。观察者和主题之间没有固定的链接。观察者可以随时注册和移除。主题或观察者的更改对彼此没有影响，并且两者都可以彼此独立地重复使用。

#### &#xD;3.7.3 装饰器

装饰器动态且透明地为组件添加新功能，而无需扩展组件本身。

图3-24Decorator\
装饰器的实例在要装饰的类之前插入，并且具有与要装饰的类相同的接口。现在，调用被转发或由装饰器处理，并且调用者不知道已经插入了装饰器。一个或多个特定的装饰器定义并实现各种特殊的装饰。

#### 3.7.4 代理

客户必须访问特定类的实例的操作。然而，可能直接访问该类的操作是不可能的、困难的或不适当的——例如，如果直接访问不安全或效率低下，或者如果您在分布式环境中工作。在这种情况下，可能不希望在客户端中将物理网络地址（用于直接访问分布式对象）硬编码。然而，没有这个地址，通过网络的直接访问是不可能的。\
在这种情况下，代理模式可以提供帮助。客户端不是与所讨论的类进行通信，而是与代理进行通信。代理向外部提供与要调用的类的实例相同的接口，而在内部，代理将调用转发到该类的一个实例。

图3-25Proxy\
• 客户端是通过代理访问真实主题的对象。\
• 代理向外部提供与真实主题相同的接口。\
• 主题定义了代理和真实主题的公共接口，并允许使用代理而不是真实主题。\
• 真实主题是由代理表示的对象。

#### &#xD;3.7.5 门面

门面是减少系统组件之间依赖关系的另一种方式。\
借助facade，子系统的内部组件对外不可见。它为复杂的子系统呈现了一个简化的接口。\
例如，如果子系统包含大量面向技术的类，而这些类很少或从未被外部使用，那么此模式就很有用。

图3-26Facade

#### &#xD;3.7.6 桥接

在软件开发的背景下，桥接模式是一种设计模式，属于结构模式类别。\
此模式用于将实现与其抽象（接口）分离，允许两者相互独立地更改。\
通常，通过对抽象的继承来实现一个实现。然而，这可能导致继承层次结构同时包含实现和其他抽象类。这增加了继承层次结构的复杂性，并使其难以维护。\
如果抽象类和实现分别在两个不同的层次结构中进行管理，这不仅增加了清晰度，而且使应用程序独立于实现。

图3-27Bridge

#### 3.7.7 State

此模式用于封装对象的不同的、依赖于状态的行为。对象的行为通常取决于其状态。应避免在大型 switch 语句中的常规实现，而是在单独的类中实现 switch 语句的每个情况。这样，对象的状态再次成为一个对象。\
图3-28State

#### &#xD;3.7.8 中介者

中介者是一个仲裁者，控制着对象的协作行为。对象之间不是直接相互协作，而是通过中介者进行协作。\
参与交互的组件被称为同事。它们知道作为交互伙伴注册的中介者。

图3-29Mediator\
特定的中介者封装了多个特定组件之间复杂的交互。\
组件之间的通信控制在一个单一的位置进行，这增加了可理解性并简化了维护。
